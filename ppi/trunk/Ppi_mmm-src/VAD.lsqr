c
c----------------------------------------------------------------------X
c
      SUBROUTINE VAD(IOUT,IIN1,NIN2,C1,C2,C3,C4,NPRNT,NAMDBZ,X0,Y0,H0)
C
C     Basterized VAD.f to include the least-squares approach.  Here I've
C     replaced the VAD results in COMMON /VADWINDS/ for comparing the
C     plots with those from the Fourier series approach.  A full 360-deg
C     scan circle is required to obtain comparable results.  Any partial
C     sector solutions are highly unstable and only resemble the 300-deg
C     solution when significant portions of the circle are taken from
C     each quadrant.
C
C  FUNCTION - COMPUTE MEAN RADIAL VELOCITY USING VAD ANALYSIS
C             F(I,J,OUT)=A0*A(1)*COS(A)*A(2)*COS(2*A)
C                          +B(1)*SIN(A)+B(2)*SIN(2*A)
C
C     DAT    - I/O data array in COMMON/DATA/DAT(MXR,MXA,MXF)
C     IOUT   - OUTPUT FIELD NUMBER (CONTAINS THE VAD ANALYTIC WINDS)
C     IIN1   -  INPUT   "      "   FOR RADIAL VELOCITY
C     IIN2   -  INPUT   "      "   FOR DBZ
C     NIN2   - TYPE OF OUTPUT ('FIT', 'RESD', 'MEASff.f')
C              FIT      - OUTPUT IS THE RADIAL VELOCITY FROM VAD FIT
C              RESD     - VR(IN) - VR(VAD)
C              MEASff.f - VR(IN), ONLY IF ABS(RESD) < ff.f
C     C1     - MINIMUM NUMBER OF GOOD DATA POINTS FOR VAD ANALYSIS
C     C2     - MAXIMUM ALLOWED AZIMUTH GAP         "   "      "
C     C3     -    "       "    RMS DIFFERENCE BETWEEN INPUT AND VAD WINDS
C     C4     - ORDER OF FIT [LINEAR INCLUDES A(1), A(2), B(1), B(2)]
C     NPRNT  - PRINT FLAG FOR VAD WINDS ('    ') NO, ('PRNT') YES,
C              ('FILE') YES and COEFFICIENTS TO ASCII FILE (fort.999).
C     NAMDBZ - Name of DBZ field to be averaged around an azimuth circle.
C     X0,Y0,H0 - Coordinates of the radar
C
C  VAD MEAN OUTPUT QUANTITIES STORED IN COMMON/VADWINDS/:
C     U0,V0  - HORIZONTAL WINDS       FOR THE ITH RANGE GATE
C     SPD    -     "      WIND SPEED   "   "   "    "     "
C     DIR    -     "       "   DIREC   "   "   "    "     "
C     CON    -     "      CONVERGENCE  "   "   "    "     "
C     WVD    - VERTICAL WIND (CON)     "   "   "    "     "
C     STR    - STRETCHING DEFORMATION  "   "   "    "     "
C     SHR    - SHEARING        "       "   "   "    "     "
C     ERR    - RMS DIFFERENCE BETWEEN FOURIER FIT AND INPUT RADIAL VEL
C     DBZ    - MEAN REFLECTIVITY FACTOR FOR THE ITH RANGE GATE
C     U_VD   - AMOUNT TO SUBTRACT FROM U-COMPONENT
C     V_VD   -    "    "     "      "  V    "
C     AZMVD  - AZIMUTH OF POSITIVE U DIRECTION
C     IFLVAD - FIELD INDEX FROM NAMFLD TO BE ASSOCIATED WITH VAD FIELD
C              NAMVD, WHERE NAMVD IS SUBSET OF NAMFLD.
C
C     Linear wind with divergence, deformations, and vorticity.
C
C        div=du/dx+dv/dy=ux+vy
C        str=du/dx-dv/dy=ux-vy
C        shr=du/dy+dv/dx=uy+vx
C        vor=dv/dx-du/dy=vx-uy
C        u(x,y)=ue+ux*(x-xe)+uy*(y-ye)
C        u(x,y)=ue+0.5*(div+str)*(x-xe)+0.5*(shr-vor)*(y-ye)
C        v(x,y)=ve+vx*(x-xe)+vy*(y-ye)
C        v(x,y)=ve+0.5*(shr+vor)*(x-xe)+0.5*(div-str)*(y-ye)
C
C     Linear equations to be solved:
C     
C     ue*Aue + ve*Bue + ux*Cue + uy*Due + vx*Eue + vy*Fue = Gue
C     ue*Ave + ve*Bve + ux*Cve + uy*Dve + vx*Eve + vy*Fve = Gve
C     ue*Aux + ve*Bux + ux*Cux + uy*Dux + vx*Eux + vy*Fux = Gux
C     ue*Auy + ve*Buy + ux*Cuy + uy*Duy + vx*Euy + vy*Fuy = Guy
C     ue*Avx + ve*Bvx + vx*Cvx + uy*Dvx + vx*Evx + vy*Fvx = Gvx
C     ue*Avy + ve*Bvy + ux*Cvy + uy*Dvy + vx*Evy + vy*Fvy = Gvy
C
C     Linear equations in matrix form:
C
C     |Aue Bue Cue Due Eue Fue| |ue|   |Gue|
C     |Ave Bve Cve Dve Eve Fve| |ve|   |Gve|
C     |Aux Bux Cux Dux Eux Fux| |ux|   |Gux|
C     |                       | |  | = |   |
C     |Auy Buy Cuy Duy Euy Fuy| |uy|   |Guy|
C     |Avx Bvx Cvx Dvx Evx Fvx| |vx|   |Gvx|
C     |Avy Bvy Cvy Dvy Evy Fvy| |vy|   |Gvy|
C
C     Linear equations in matrix form:
C
C     |a11 a12 a13 a14 a15 a16| |x1|   |b1|
C     |a21 a22 a23 a24 a25 a26| |x2|   |b2|
C     |a31 a32 a33 a34 a35 a36| |x3|   |b3|
C     |                       | |  | = |  |
C     |a41 a42 a43 a44 a45 a46| |x4|   |b4|
C     |a51 a52 a53 a54 a55 a56| |x5|   |b5|
C     |a61 a62 a63 a64 a65 a66| |x6|   |b6|
C
      parameter(np = 6)
c      real al(np,np),ul(np,np),wl(np),vl(np,np),bl(np),xl(np)
      DOUBLE PRECISION al(np,np),ul(np,np),wl(np),vl(np,np)
      DOUBLE PRECISION bl(np),xl(np)

      INCLUDE 'dim.inc'
      INCLUDE 'data.inc'
      INCLUDE 'input.inc'
      INCLUDE 'swth.inc'
      INCLUDE 'vadwinds.inc'

      PARAMETER (MXFC=7)

      COMMON /INPUTCH/NAMFLD(MXF),IRATYP,ICORD
      CHARACTER*8 NAMFLD,IRATYP,ICORD
      COMMON/SCRATCH/TMP1(MXR),TMP2(MXR,MXA)

      DATA RE,REI/17000.0,1.17647E-04/
      DATA TORAD,TODEG/0.017453293,57.29577951/
      DATA CNT0,GAP0,RMS0/15.0,30.0,999.9/
      DATA EPS/0.1/
      LOGICAL PLTSW
      CHARACTER*8 NIN2,NPRNT,AVTYP,NAMDBZ
      CHARACTER*4 TYPOUT
      DIMENSION A(MXFC),B(MXFC)

      CHARACTER*8 AVNAM
      DATA AVNAM/'??????? '/

      dimension ue(mxg),ve(mxg),spdl(mxg),dirl(mxg)
      dimension conl(mxg),strl(mxg),shrl(mxg),vorl(mxg)

      print *,'X0,Y0,H0=',X0,Y0,H0

      IF(FXOLD.GT.60.0)THEN
         WRITE(6,5)FXOLD
 5       FORMAT(1X,'*** CANNOT DO VAD ANALYSIS: E> ',F6.2,' DEG ***')
         RETURN
      END IF

C  FIND INDEX FOR REFLECTIVITY FACTOR TO BE AVERAGED
C
      IIN2=IFIND(NAMDBZ,NAMFLD,MXF)

C  FIND VAD-FIELD INDEX FOR THE CURRENT OUTPUT FIELD NAME
C
      KVD=IFIND(NAMFLD(IOUT),NAMVD,MXVD)
      print *,'kvd,u_vd,v_vd=',kvd,U_VD(KVD),V_VD(KVD)

      IF(C1.GT.0.0)THEN
         CNTMN=C1
      ELSE
         CNTMN=CNT0
      END IF
      IF(C2.GT.0.0)THEN
         TGAP=C2
      ELSE
         TGAP=GAP0
      END IF
      IF(C3.GT.0.0)THEN
         RMSMX=C3
      ELSE
         RMSMX=RMS0
      END IF
      IF(C4.GT.0.0)THEN
         KFIT=MIN0(MXFC,INT(C4))
      ELSE
         KFIT=2
      END IF
      READ(NIN2,7)TYPOUT,DIFMX
 7    FORMAT(A4,F4.0)
      IF(DIFMX.EQ.0.0)DIFMX=VNYQ

      SINE=SIN(TORAD*FXOLD)
      COSE=COS(TORAD*FXOLD)
      SINA=SIN(TORAD*AZMVD(KVD))
      COSA=COS(TORAD*AZMVD(KVD))

      MING=MAX0(MNGATE,1)
      MAXG=MIN0(MXGATE,MXG,MXR)

C     Initialize all VAD variables to bad data value
C
      DO 10 I=1,MAXG
         U0(I,KVD) =BDVAL
         V0(I,KVD) =BDVAL
         SPD(I,KVD)=BDVAL
         DIR(I,KVD)=BDVAL
         CON(I,KVD)=BDVAL
         WVD(I,KVD)=BDVAL
         STR(I,KVD)=BDVAL
         SHR(I,KVD)=BDVAL
         ERR(I,KVD)=BDVAL
         DBZ(I,KVD)=BDVAL
         AVAD0(I,KVD)=BDVAL
         DO K=1,2
            AVAD(I,KVD,K)=BDVAL
            BVAD(I,KVD,K)=BDVAL
         END DO
         ue(i) = bdval
         ve(i) = bdval
         spdl(i) = bdval
         dirl(i) = bdval
         conl(i) = bdval
         strl(i) = bdval
         shrl(i) = bdval
         vorl(i) = bdval
 10   CONTINUE
      WVD(MNGATE,KVD)=0.0

C     COMPUTE AVERAGE OR INTEGRAL THROUGH CURRENT SWEEP
C
      IF(IFLD(IIN1).LT.0)THEN
         ISW=2
         PLTSW=.TRUE.
         GSPC=DRSW
         IFLD(IOUT)=-1
      ELSE
         ISW=1
         PLTSW=.FALSE.
         GSPC=DROLD
         IF(NAMFLD(IOUT).EQ.NAMFLD(IIN1))THEN
            IFLD(IOUT)=IFLD(IIN1)
         ELSE
            IFLD(IOUT)=0
         END IF
      END IF
      AVTYP='SNGLSWP '
      ITIM1=IFTIME
      ITIM2=ITIME
      WRITE(*,*)"VAD: ",NAMFLD(IOUT),NAMFLD(IIN1),PLTSW,NPRNT,NIN2,GSPC

      IFL=IIN1
      IFLVAD(KVD)=IOUT
      IF(IFLD(IFL).EQ.-5.OR.IFLD(IFL).EQ.-6)THEN
         CALL AVRAGE(DAT,MXR,MXA,MXF,BDVAL,MNGATE,MXGATE,NANG,
     X        NAMFLD,IFLD,IFL,AVNAM)
         AVTYP='AVERAGE '
         ITIM1=ITIME1
         ITIM2=ITIME2
      END IF

      IF(NPRNT.EQ.'FILE')THEN
         CALL LABELFL(PLTSW)
         WRITE(999,13)MSCAN,AVTYP,ITIM1,ITIM2,
     +        NAMFLD(IIN1),IIN1,IFLD(IIN1),
     +        NAMFLD(IOUT),IOUT,IFLD(IOUT)
 13      FORMAT(2X,'SCAN #',I3,2X,A8,I6.6,'-',I6.6,
     +          2X,'VAD  (NAME,INDEX,TYPE):  IN=',A8,2I4,
     +             ' OUT=',A8,2I4,' *VAD*')
         WRITE(999,15)
 15      FORMAT(10X,'R    Z       A0      A1      A2      B1      B2  ',
     +              '    U0      V0      SPD     DIR     CON     STR  ',
     +              '   SHR     ERR     DBZ')
      END IF

C     Copy all radial velocities into TMP2 array (Range x Azimuth).
C
      DO I=MING,MAXG
         DO J=1,NANG(ISW)
            TMP2(I,J)=DAT(I,J,IIN1)
         END DO
      END DO

C     Outer-loop (100) over ranges, inner-loop (90) over azimuths.
C
      DO 100 I=MING,MAXG

         IF(RNG(I,ISW).LE.EPS.OR.RNG(I,ISW).GT.40.0)GO TO 100
         HRNG=RNG(I,ISW)*COSE
c         Z=H0+RNG(I,ISW)*SINE+0.5*HRNG*HRNG*REI
         Z=H0+RNG(I,ISW)*SINE

C     Initialize all variables for this range 
C     before looping around an azimuthal circle.
C
         IF(KVD.EQ.1)THEN
            SUMDBZ=0.0
            CNTDBZ=0.0
         ELSE
            SUMDBZ=BDVAL
         END IF

C     Variables for Fourier series
C
         A0=0.0
         DO K=1,MXFC
            A(K)=0.0
            B(K)=0.0
         END DO

         CNT=0.0
         CNTDBZ=0.0
         GAPMX=-999.0
         GAPMN=999.0
         ALFT=BDVAL

C     Variables for linear least-squares fit
C
         do m=1,6
            bl(m) = 0.0
            do n=1,6
               al(m,n) = 0.0
            end do
         end do

C        Inner-loop over azimuth angles.  Calculate the Fourier 
C        coefficients for ZEROth, and First through Kth harmonics
C        at the current range gate [RNG(I,ISW)].
C
         DO 90 J=1,NANG(ISW)
            ANG=AZA(J,ISW)
C            IF(ANG.LT.0.0)ANG=ANG+360.0
            ANGR=ANG*TORAD
	    SINAZ=SIN(ANGR)
            COSAZ=COS(ANGR)
            X=X0+HRNG*SINAZ
            Y=Y0+HRNG*COSAZ
            IF(TMP2(I,J).NE.BDVAL)THEN
               IF(KVD.EQ.1 .AND. IIN2.GT.0 .AND. 
     X            DAT(I,J,IIN2) .NE. BDVAL)THEN
                  SUMDBZ=SUMDBZ+DAT(I,J,IIN2)
                  CNTDBZ=CNTDBZ+1.0
               END IF
               A0=A0+TMP2(I,J)
               DO K=1,KFIT
                  A(K)=A(K)+TMP2(I,J)*COS(ANGR*K)
                  B(K)=B(K)+TMP2(I,J)*SIN(ANGR*K)
               END DO

C--------------------------------------------------------------
C     Now check if linear has good results if summation is over
C     a sector rather than the whole circle.
C
c               ang1 = 0.0
c               ang2 = ang1 + 315.0
c               if((ang .gt. 000.0 .and. ang .lt. 010.0) .or.
c     x            (ang .gt. 080.0 .and. ang .lt. 100.0) .or.
c     x            (ang .gt. 170.0 .and. ang .lt. 190.0) .or.
c     x            (ang .gt. 260.0 .and. ang .lt. 280.0) .or.
c     x            (ang .gt. 350.0 .and. ang .lt. 360.0))then
               Vri = TMP2(I,J)
               Ri = RNG(I,ISW)
               RiVri = RNG(I,ISW)*TMP2(I,J)
               xi = x
               yi = y
               xr = x0
               yr = y0
               xe = 0
               ye = 0
               print *,'r,az,x,y=',ri,ang,xi,yi,' vr=',vri

C     I may still have these transposed.  If so search on "," then move right
C     to number and hit ESC+t.  Repeat in blocks of 12.
C     Row 1: ue equation
C
               AL(1,1) = AL(1,1) + (xi-xr)*(xi-xr)
               AL(1,2) = AL(1,2) + (yi-yr)*(xi-xr)
               AL(1,3) = AL(1,3) + (xi-xe)*(xi-xr)*(xi-xr)
               AL(1,4) = AL(1,4) + (yi-ye)*(xi-xr)*(xi-xr)
               AL(1,5) = AL(1,5) + (xi-xe)*(yi-yr)*(xi-xr)
               AL(1,6) = AL(1,6) + (yi-ye)*(yi-yr)*(xi-xr)
               BL(1)   = BL(1)   + RiVri*(xi-xr)
               
C     Row 2: ve equation
C
               AL(2,1) = AL(2,1) + (xi-xr)*(yi-yr)
               AL(2,2) = AL(2,2) + (yi-yr)*(yi-yr)
               AL(2,3) = AL(2,3) + (xi-xe)*(xi-xr)*(yi-yr)
               AL(2,4) = AL(2,4) + (yi-ye)*(xi-xr)*(yi-yr)
               AL(2,5) = AL(2,5) + (xi-xe)*(yi-yr)*(yi-yr)
               AL(2,6) = AL(2,6) + (yi-ye)*(yi-yr)*(yi-yr)
               BL(2)   = BL(2)   + RiVri*(yi-yr)
               
C     Row 3: ux equation
C
               AL(3,1) = AL(3,1) + (xi-xr)*(xi-xe)*(xi-xr)
               AL(3,2) = AL(3,2) + (yi-yr)*(xi-xe)*(xi-xr)
               AL(3,3) = AL(3,3) + (xi-xe)*(xi-xr)*(xi-xe)*(xi-xr)
               AL(3,4) = AL(3,4) + (yi-ye)*(xi-xr)*(xi-xe)*(xi-xr)
               AL(3,5) = AL(3,5) + (xi-xe)*(yi-yr)*(xi-xe)*(xi-xr)
               AL(3,6) = AL(3,6) + (yi-ye)*(yi-yr)*(xi-xe)*(xi-xr)
               BL(3)   = BL(3)   + RiVri*(xi-xe)*(xi-xr)
               
C     Row 4: uy equation
C
               AL(4,1) = AL(4,1) + (xi-xr)*(yi-ye)*(xi-xr)
               AL(4,2) = AL(4,2) + (yi-yr)*(yi-ye)*(xi-xr)
               AL(4,3) = AL(4,3) + (xi-xe)*(xi-xr)*(yi-ye)*(xi-xr)
               AL(4,4) = AL(4,4) + (yi-ye)*(xi-xr)*(yi-ye)*(xi-xr)
               AL(4,5) = AL(4,5) + (xi-xe)*(yi-yr)*(yi-ye)*(xi-xr)
               AL(4,6) = AL(4,6) + (yi-ye)*(yi-yr)*(yi-ye)*(xi-xr)
               BL(4) = BL(4) + RiVri*(yi-ye)*(xi-xr)
               
C     Row 5: vx equation
C
               AL(5,1) = AL(5,1) + (xi-xr)*(xi-xe)*(yi-yr)
               AL(5,2) = AL(5,2) + (yi-yr)*(xi-xe)*(yi-yr)
               AL(5,3) = AL(5,3) + (xi-xe)*(xi-xr)*(xi-xe)*(yi-yr)
               AL(5,4) = AL(5,4) + (yi-ye)*(xi-xr)*(xi-xe)*(yi-yr)
               AL(5,5) = AL(5,5) + (xi-xe)*(yi-yr)*(xi-xe)*(yi-yr)
               AL(5,6) = AL(5,6) + (yi-ye)*(yi-yr)*(xi-xe)*(yi-yr)
               BL(5)   = BL(5)   + RiVri*(xi-xe)*(yi-yr)
               
C     Row 6: vy equation
C
               AL(6,1) = AL(6,1) + (xi-xr)*(yi-ye)*(yi-yr)
               AL(6,2) = AL(6,2) + (yi-yr)*(yi-ye)*(yi-yr)
               AL(6,3) = AL(6,3) + (xi-xe)*(xi-xr)*(yi-ye)*(yi-yr)
               AL(6,4) = AL(6,4) + (yi-ye)*(xi-xr)*(yi-ye)*(yi-yr)
               AL(6,5) = AL(6,5) + (xi-xe)*(yi-yr)*(yi-ye)*(yi-yr)
               AL(6,6) = AL(6,6) + (yi-ye)*(yi-yr)*(yi-ye)*(yi-yr)
               BL(6)   = BL(6)   + RiVri*(yi-ye)*(yi-yr)
c               endif
C     Now check if linear has good results if summation is over
C     a sector rather than the whole circle.
C--------------------------------------------------------------

               CNT=CNT+1.0
               IF(ALFT.EQ.BDVAL)THEN
                  ALFT=ANG
               ELSE
                  GAP=ABS(ANG-ALFT)
                  ALFT=ANG
                  IF(GAP.GT.180.0)GAP=ABS(GAP-360.0)
                  IF(GAP.LT.GAPMN)GAPMN=GAP
                  IF(GAP.GT.GAPMX)GAPMX=GAP
               END IF
            END IF
 90      CONTINUE

C     FROM FOURIER COEFFICIENTS:  CALCULATE THE VAD MEAN PARAMETERS
C     AND VAD ANALYTIC WINDS FOR THIS RANGE, THEN GO ON TO NEXT RANGE
C     
         IF(CNT.GE.CNTMN.AND.GAPMX.LE.TGAP)THEN
         
C     Calculate the wind parameters from the linear coefficients
C

c------------------------------------------------
c     Copy al into ul so as not to destroy al.
c
            n = np            
            do ii=1,n
               do jj=1,n
                  ul(ii,jj)=al(ii,jj)
               enddo
            enddo
            
c     Compute the singular value decomposition of u=a.
c
c            call svdcmp(ul,n,n,np,np,wl,vl)
            call dsvdcmp(ul,n,n,np,np,wl,vl)

c     Set the maximum (wmax) singular value allowed.
c     
            wmax=0.
            do jj=1,n
               if(wl(jj).gt.wmax)wmax=wl(jj)
            end do
            
c     Set the threshold (wmin) for singular values allowed
c     to be nonzero.
c
            wmin=wmax*1.0e-6
            do jj=1,n
               if(wl(jj).lt.wmin)wl(jj)=0.
            enddo
            print *,'wmax,wmin=',wmax,wmin

c     Finally, solve |A||x| = |B| for the vector |x|
c     using the backsubstitution method.
c
c            call svbksb(ul,wl,vl,n,n,np,np,bl,xl)
            call dsvbksb(ul,wl,vl,n,n,np,np,bl,xl)

            DO M=1,6
               write(6,1700)m,BL(M),(ul(m,n),n=1,6),xl(m)
 1700          format('m,bl,ul=',i1,7f10.4,' xl=',f10.4)
            END DO

c     Linear winds from least-squares solution.
c
c     ue=xl(1), ve=xl(2), ux=xl(3), uy=xl(4), vx=xl(5), vy=xl(6)
c     divl=ux+vy=xl(3)+xl(6)
c     strl=ux-vy=xl(3)-xl(6)
c     shrl=uy+vx=xl(4)+xl(5)
c     vorl=vx-uy=xl(5)-xl(4)
c
            ue(i)   = xl(1)            
            ve(i)   = xl(2)            
            divl    = xl(3)+xl(6)
            conl(i) = -divl
            strl(i) = xl(3)-xl(6)
            shrl(i) = xl(4)+xl(5)
            vorl(i) = xl(5)-xl(4)
            spdl(i) = sqrt(ue(i)*ue(i)+ve(i)*ve(i))
            if(ve(i).eq.0.0.and.ue(i).eq.0.0)then
               dirl(i)=180.0
            else if(ve(i).eq.0.0.and.ue(i).gt.0.0)then
               dirl(i)=90.0
            else if(ve(i).eq.0.0.and.ue(i).lt.0.0)then
               dirl(i)=270.0
            else
               dirl(i)=todeg*atan2(ue(i),ve(i))
               if(dirl(i).lt.0.0)dirl(i)=dirl(i)+360.0
            end if
            dirl(i)=dirl(i)+180.0
            if(dirl(i).ge.360.0)dirl(i)=dirl(i)-360.0

c            print *,'X=',xl
c            print *,'    ue=',xl(1)
c            print *,'    ve=',xl(2)
c            print *,'  divl=',divl
c            print *,'  strl=',strl
c            print *,'  shrl=',shrl
c            print *,'  vorl=',vorl
            WRITE(6,1701)I,RNG(I,ISW),Z,ue(i),
     +           ve(i),spdl(i),dirl(i),conl(i),
     +           strl(i),shrl(i),vorl(i)
 1701       FORMAT(1X,'    IRZ=',I4,2F8.3,'  uvsd=',4F8.2,
     +           '  cth=',3F8.2,' vor=',F8.2)
c------------------------------------------------

            IF(KVD.EQ.1)THEN
               IF(CNTDBZ.NE.0.0)THEN
                  DBZ(I,KVD)=SUMDBZ/CNTDBZ
               ELSE
                  DBZ(I,KVD)=BDVAL
               END IF
            ELSE
               DBZ(I,KVD)=DBZ(I,1)
            END IF
            A0=A0/CNT
            AVAD0(I,KVD)=A0
            DO K=1,KFIT
               A(K)=2.0*A(K)/CNT
               B(K)=2.0*B(K)/CNT
               IF(K.LE.2)THEN
                  AVAD(I,KVD,K)=A(K)
                  BVAD(I,KVD,K)=B(K)
               END IF
            END DO
            
            UMN=(B(1)/COSE)-U_VD(KVD)
            VMN=(A(1)/COSE)-V_VD(KVD)
            U0(I,KVD)= UMN*SINA + VMN*COSA
            V0(I,KVD)=-UMN*COSA + VMN*SINA
            SPD(I,KVD)=SQRT(U0(I,KVD)*U0(I,KVD)+V0(I,KVD)*V0(I,KVD))
            IF(V0(I,KVD).EQ.0.0.AND.U0(I,KVD).EQ.0.0)THEN
               DIR(I,KVD)=180.0
            ELSE IF(V0(I,KVD).EQ.0.0.AND.U0(I,KVD).GT.0.0)THEN
               DIR(I,KVD)=90.0
            ELSE IF(V0(I,KVD).EQ.0.0.AND.U0(I,KVD).LT.0.0)THEN
               DIR(I,KVD)=270.0
            ELSE
               DIR(I,KVD)=TODEG*ATAN2(U0(I,KVD),V0(I,KVD))
               IF(DIR(I,KVD).LT.0.0)DIR(I,KVD)=DIR(I,KVD)+360.0
            END IF
            DIR(I,KVD)=DIR(I,KVD)+180.0
            IF(DIR(I,KVD).GE.360.0)DIR(I,KVD)=DIR(I,KVD)-360.0
            CON(I,KVD)=-2.0*A0/(RNG(I,ISW)*COSE*COSE)
            IF(I.GT.MNGATE)THEN
               WVD(I,KVD)=WVD(I-1,KVD)
     +                   +0.5*GSPC*SINE*(CON(I,KVD)+CON(I-1,KVD))
            END IF
            STR(I,KVD)=-2.0*A(2)/(RNG(I,ISW)*COSE*COSE)
            SHR(I,KVD)= 2.0*B(2)/(RNG(I,ISW)*COSE*COSE)

            SUMSQDIF=0.0
            CNTDIF=0.0
            DO 92 J=1,NANG(ISW)
               ANG=AZA(J,ISW)
C               IF(ANG.LT.0.0)ANG=ANG+360.0
               ANGR=ANG*TORAD
               VRVAD=A0
               DO K=1,KFIT
                  VRVAD=VRVAD+A(K)*COS(ANGR*K)+B(K)*SIN(ANGR*K)
               END DO
               
               VRINP=TMP2(I,J)
               IF(VRINP.NE.BDVAL)THEN
                  CNTDIF=CNTDIF+1.0
                  VRDIF=VRINP-VRVAD
                  SUMSQDIF=SUMSQDIF+VRDIF*VRDIF
               ELSE
                  VRDIF=BDVAL
               END IF
               
               IF(TYPOUT.EQ.'FIT ')THEN
                  DAT(I,J,IOUT)=VRVAD
               ELSE IF(TYPOUT.EQ.'RESD')THEN
                  DAT(I,J,IOUT)=VRDIF
               ELSE IF(TYPOUT.EQ.'MEAS')THEN
                  IF(ABS(VRDIF).LE.DIFMX)THEN
                     DAT(I,J,IOUT)=VRINP
                  ELSE
                     DAT(I,J,IOUT)=BDVAL
                  END IF
               ELSE
                  DAT(I,J,IOUT)=VRVAD
               END IF

 92         CONTINUE

C           CHECK RMS DIFFERENCE BETWEEN VAD AND INPUT WINDS.
C           IF BIGGER THAN RMSMX=C3, THEN SET VAD WINDS TO BDVAL.
C
            IF(CNTDIF.GT.CNTMN)THEN
               RMSDIF=SQRT(SUMSQDIF/CNTDIF)
               ERR(I,KVD)=RMSDIF
            ELSE
               ERR(I,KVD)=BDVAL
            END IF
            IF(RMSDIF.GT.RMSMX)THEN
               U0(I,KVD) =BDVAL
               V0(I,KVD) =BDVAL
               DIR(I,KVD)=BDVAL
               SPD(I,KVD)=BDVAL
               CON(I,KVD)=BDVAL
               WVD(I,KVD)=BDVAL
               STR(I,KVD)=BDVAL
               SHR(I,KVD)=BDVAL
               DBZ(I,KVD)=BDVAL
               DO J=1,NANG(ISW)
                  DAT(I,J,IOUT)=BDVAL
               END DO
            END IF
         ELSE
            U0(I,KVD) =BDVAL
            V0(I,KVD) =BDVAL
            DIR(I,KVD)=BDVAL
            SPD(I,KVD)=BDVAL
            CON(I,KVD)=BDVAL
            WVD(I,KVD)=BDVAL
            STR(I,KVD)=BDVAL
            SHR(I,KVD)=BDVAL
            ERR(I,KVD)=BDVAL
            DBZ(I,KVD)=BDVAL
            DO J=1,NANG(ISW)
               DAT(I,J,IOUT)=BDVAL
            END DO
            A0=BDVAL
            AVAD0(I,KVD)=BDVAL
            DO K=1,KFIT
               A(K)=BDVAL
               B(K)=BDVAL
               IF(K.LE.2)THEN
                  AVAD(I,KVD,K)=BDVAL
                  BVAD(I,KVD,K)=BDVAL
               END IF
            END DO
         END IF
         
 100  CONTINUE
      
C     LINEARLY INTERPOLATE TO FILL MISSING GATES
C
      DO 110 I=1,MAXG
         Z=H0+RNG(I,ISW)*SINE
         IF(I.EQ.1.OR.I.EQ.MAXG)GO TO 102
         IL=I-1
         IR=I+1
         IF(U0( I,KVD).EQ.BDVAL.AND.
     +      U0(IL,KVD).NE.BDVAL.AND.
     +      U0(IR,KVD).NE.BDVAL)THEN
            U0(I,KVD) =0.5*(U0(IL,KVD)+U0(IR,KVD))
            V0(I,KVD) =0.5*(V0(IL,KVD)+V0(IR,KVD))
            SPD(I,KVD)=0.5*(SPD(IL,KVD)+SPD(IR,KVD))
            IF((DIR(IL,KVD)-DIR(IR,KVD)).GT.180.0)THEN
               DIR(IR,KVD)=DIR(IR,KVD)+360.0
            ELSE IF ((DIR(IR,KVD)-DIR(IL,KVD)).GT.180.0)THEN
               DIR(IL,KVD)=DIR(IL,KVD)+360.0
            END IF
            DIR(I,KVD)=0.5*(DIR(IL,KVD)+DIR(IR,KVD))
            IF(DIR(I,KVD).GT.360.0)DIR(I,KVD)=DIR(I,KVD)-360.0
            CON(I,KVD)=0.5*(CON(IL,KVD)+CON(IR,KVD))
            WVD(I,KVD)=0.5*(WVD(IL,KVD)+WVD(IR,KVD))
            STR(I,KVD)=0.5*(STR(IL,KVD)+STR(IR,KVD))
            SHR(I,KVD)=0.5*(SHR(IL,KVD)+SHR(IR,KVD))
            ERR(I,KVD)=0.5*(ERR(IL,KVD)+ERR(IR,KVD))
            DBZ(I,KVD)=0.5*(DBZ(IL,KVD)+DBZ(IR,KVD))
         END IF
         IF(AVAD0( I,KVD).EQ.BDVAL.AND.
     +      AVAD0(IL,KVD).NE.BDVAL.AND.
     +      AVAD0(IR,KVD).NE.BDVAL)THEN
            AVAD0(I,KVD)=0.5*(AVAD0(IL,KVD)+AVAD0(IR,KVD))
            DO K=1,2
               AVAD(I,KVD,K)=0.5*(AVAD(IL,KVD,K)+AVAD(IR,KVD,K))
               BVAD(I,KVD,K)=0.5*(BVAD(IL,KVD,K)+BVAD(IR,KVD,K))
            END DO
         END IF

 102     CONTINUE


C     Temporarily transfer linear least-squares results into 
C     fourier arrays for operations in the rest of the code.
C--------------------------
         u0(i,kvd) =ue(i)
         v0(i,kvd) =ve(i)
         spd(i,kvd)=spdl(i)
         dir(i,kvd)=dirl(i)
         con(i,kvd)=conl(i)
         str(i,kvd)=strl(i)
         shr(i,kvd)=shrl(i)
C--------------------------

         IF(U0(I,KVD).NE.BDVAL)THEN
            IF(NPRNT.EQ.'PRNT'.OR.NPRNT.EQ.'FILE')THEN
               WRITE(6,103)I,RNG(I,ISW),Z,U0(I,KVD),
     +              V0(I,KVD),SPD(I,KVD),DIR(I,KVD),CON(I,KVD),
     +              STR(I,KVD),SHR(I,KVD),ERR(I,KVD),DBZ(I,KVD)
 103           FORMAT(1X,'    IRZ=',I4,2F8.3,'  UVSD=',4F8.2,
     +              '  CTH=',3F8.2,' ERR=',F8.2,' DBZ=',F8.2)
            END IF
            IF(NPRNT.EQ.'FILE')THEN
               WRITE(999,105)KVD,I,RNG(I,ISW),Z,AVAD0(I,KVD),
     +              AVAD(I,KVD,1),AVAD(I,KVD,2),BVAD(I,KVD,1),
     +              BVAD(I,KVD,2),U0(I,KVD),V0(I,KVD),SPD(I,KVD),
     +              DIR(I,KVD),CON(I,KVD),STR(I,KVD),SHR(I,KVD),
     +              ERR(I,KVD),DBZ(I,KVD)
 105           FORMAT('I=',I2,I3,F6.2,F6.3,14F8.2)
            END IF
         END IF

 110  CONTINUE

C     RESTORE AVERAGE ACCUMULATORS
C
      IF(IFLD(IFL).EQ.-5.OR.IFLD(IFL).EQ.-6)THEN
         CALL UNAVRAGE(DAT,MXR,MXA,MXF,BDVAL,MNGATE,MXGATE,NANG,
     X        NAMFLD,IFLD,IFL,AVNAM)
      END IF

      RETURN
      END
c
c----------------------------------------------------------------------X
c
      SUBROUTINE svdcmp(a,m,n,mp,np,w,v)
c     
c     Given a matrix a(1:m,1:n), with physical dimension mp by np, this
c     routine computes its singular value decomposition, A = U*W*V^T.  
c     The martrix U replaces a on output.  The diagaonal matrix of 
c     singular values W is output as a vector w(1:n).  The matrix V 
c     (not the transpose V^T) is output as v(1:n,1:n).
c
c        m,n    - logical dimensions of a, and will be equal for 
c                 square matrices
c        mp,np  - physical dimensions of a
c        NMAX   - maximum anticipated value of n
c        a(1:m) - the input left-hand side
c        w(1:m) - the output singular values
c        v(1:m) - the output matrix, not its transpose
c
      INTEGER m,mp,n,np,NMAX
      REAL a(mp,np),v(np,np),w(np)
      PARAMETER (NMAX=500)
CU    USES pythag
      INTEGER i,its,j,jj,k,l,nm
      REAL anorm,c,f,g,h,s,scale,x,y,z,rv1(NMAX),pythag
      g=0.0
      scale=0.0
      anorm=0.0
      do 25 i=1,n
        l=i+1
        rv1(i)=scale*g
        g=0.0
        s=0.0
        scale=0.0
        if(i.le.m)then
          do 11 k=i,m
            scale=scale+abs(a(k,i))
11        continue
          if(scale.ne.0.0)then
            do 12 k=i,m
              a(k,i)=a(k,i)/scale
              s=s+a(k,i)*a(k,i)
12          continue
            f=a(i,i)
            g=-sign(sqrt(s),f)
            h=f*g-s
            a(i,i)=f-g
            do 15 j=l,n
              s=0.0
              do 13 k=i,m
                s=s+a(k,i)*a(k,j)
13            continue
              f=s/h
              do 14 k=i,m
                a(k,j)=a(k,j)+f*a(k,i)
14            continue
15          continue
            do 16 k=i,m
              a(k,i)=scale*a(k,i)
16          continue
          endif
        endif
        w(i)=scale *g
        g=0.0
        s=0.0
        scale=0.0
        if((i.le.m).and.(i.ne.n))then
          do 17 k=l,n
            scale=scale+abs(a(i,k))
17        continue
          if(scale.ne.0.0)then
            do 18 k=l,n
              a(i,k)=a(i,k)/scale
              s=s+a(i,k)*a(i,k)
18          continue
            f=a(i,l)
            g=-sign(sqrt(s),f)
            h=f*g-s
            a(i,l)=f-g
            do 19 k=l,n
              rv1(k)=a(i,k)/h
19          continue
            do 23 j=l,m
              s=0.0
              do 21 k=l,n
                s=s+a(j,k)*a(i,k)
21            continue
              do 22 k=l,n
                a(j,k)=a(j,k)+s*rv1(k)
22            continue
23          continue
            do 24 k=l,n
              a(i,k)=scale*a(i,k)
24          continue
          endif
        endif
        anorm=max(anorm,(abs(w(i))+abs(rv1(i))))
25    continue
      do 32 i=n,1,-1
        if(i.lt.n)then
          if(g.ne.0.0)then
            do 26 j=l,n
              v(j,i)=(a(i,j)/a(i,l))/g
26          continue
            do 29 j=l,n
              s=0.0
              do 27 k=l,n
                s=s+a(i,k)*v(k,j)
27            continue
              do 28 k=l,n
                v(k,j)=v(k,j)+s*v(k,i)
28            continue
29          continue
          endif
          do 31 j=l,n
            v(i,j)=0.0
            v(j,i)=0.0
31        continue
        endif
        v(i,i)=1.0
        g=rv1(i)
        l=i
32    continue
      do 39 i=min(m,n),1,-1
        l=i+1
        g=w(i)
        do 33 j=l,n
          a(i,j)=0.0
33      continue
        if(g.ne.0.0)then
          g=1.0/g
          do 36 j=l,n
            s=0.0
            do 34 k=l,m
              s=s+a(k,i)*a(k,j)
34          continue
            f=(s/a(i,i))*g
            do 35 k=i,m
              a(k,j)=a(k,j)+f*a(k,i)
35          continue
36        continue
          do 37 j=i,m
            a(j,i)=a(j,i)*g
37        continue
        else
          do 38 j= i,m
            a(j,i)=0.0
38        continue
        endif
        a(i,i)=a(i,i)+1.0
39    continue
      do 49 k=n,1,-1
        do 48 its=1,30
          do 41 l=k,1,-1
            nm=l-1
            if((abs(rv1(l))+anorm).eq.anorm)  goto 2
            if((abs(w(nm))+anorm).eq.anorm)  goto 1
41        continue
1         c=0.0
          s=1.0
          do 43 i=l,k
            f=s*rv1(i)
            rv1(i)=c*rv1(i)
            if((abs(f)+anorm).eq.anorm) goto 2
            g=w(i)
            h=pythag(f,g)
            w(i)=h
            h=1.0/h
            c= (g*h)
            s=-(f*h)
            do 42 j=1,m
              y=a(j,nm)
              z=a(j,i)
              a(j,nm)=(y*c)+(z*s)
              a(j,i)=-(y*s)+(z*c)
42          continue
43        continue
2         z=w(k)
          if(l.eq.k)then
            if(z.lt.0.0)then
              w(k)=-z
              do 44 j=1,n
                v(j,k)=-v(j,k)
44            continue
            endif
            goto 3
          endif
          if(its.eq.30) pause 'no convergence in svdcmp'
          x=w(l)
          nm=k-1
          y=w(nm)
          g=rv1(nm)
          h=rv1(k)
          f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
          g=pythag(f,1.0)
          f=((x-z)*(x+z)+h*((y/(f+sign(g,f)))-h))/x
          c=1.0
          s=1.0
          do 47 j=l,nm
            i=j+1
            g=rv1(i)
            y=w(i)
            h=s*g
            g=c*g
            z=pythag(f,h)
            rv1(j)=z
            c=f/z
            s=h/z
            f= (x*c)+(g*s)
            g=-(x*s)+(g*c)
            h=y*s
            y=y*c
            do 45 jj=1,n
              x=v(jj,j)
              z=v(jj,i)
              v(jj,j)= (x*c)+(z*s)
              v(jj,i)=-(x*s)+(z*c)
45          continue
            z=pythag(f,h)
            w(j)=z
            if(z.ne.0.0)then
              z=1.0/z
              c=f*z
              s=h*z
            endif
            f= (c*g)+(s*y)
            x=-(s*g)+(c*y)
            do 46 jj=1,m
              y=a(jj,j)
              z=a(jj,i)
              a(jj,j)= (y*c)+(z*s)
              a(jj,i)=-(y*s)+(z*c)
46          continue
47        continue
          rv1(l)=0.0
          rv1(k)=f
          w(k)=x
48      continue
3       continue
49    continue
      return
      END
c
c----------------------------------------------------------------------X
c
      FUNCTION pythag(a,b)
      REAL a,b,pythag
      REAL absa,absb
      absa=abs(a)
      absb=abs(b)
      if(absa.gt.absb)then
        pythag=absa*sqrt(1.+(absb/absa)**2)
      else
        if(absb.eq.0.)then
          pythag=0.
        else
          pythag=absb*sqrt(1.+(absa/absb)**2)
        endif
      endif
      return
      END
c
c----------------------------------------------------------------------X
c
      SUBROUTINE svbksb(u,w,v,m,n,mp,np,b,x)
c
c     Solves |A||x| = |B|, where A is specified by the arrays u,w,v
c     as returned by svdcmp.  
c        m,n    - logical dimensions of a, and will be equal for 
c                 square matrices
c        mp,np  - physical dimensions of a
c        b(1:m) - the input right-hand side
c        x(1:n) - the output soulution vector
c        NMAX   - maximum anticipated value of n
c
c     No input quantities are destroyed, so the routine may be called 
c     sequentially with different b's.
c     
      INTEGER m,mp,n,np,NMAX
      REAL b(mp),u(mp,np),v(np,np),w(np),x(np)
      PARAMETER (NMAX=500)
      INTEGER i,j,jj
      REAL s,tmp(NMAX)
      do 12 j=1,n
        s=0.
        if(w(j).ne.0.)then
          do 11 i=1,m
            s=s+u(i,j)*b(i)
11        continue
          s=s/w(j)
        endif
        tmp(j)=s
12    continue
      do 14 j=1,n
        s=0.
        do 13 jj=1,n
          s=s+v(j,jj)*tmp(jj)
13      continue
        x(j)=s
14    continue
      return
      END
c
c----------------------------------------------------------------------X
c
      SUBROUTINE dsvdcmp(a,m,n,mp,np,w,v)
c     
c     Given a matrix a(1:m,1:n), with physical dimension mp by np, this
c     routine computes its singular value decomposition, A = U*W*V^T.  
c     The martrix U replaces a on output.  The diagaonal matrix of 
c     singular values W is output as a vector w(1:n).  The matrix V 
c     (not the transpose V^T) is output as v(1:n,1:n).
c
c        m,n    - logical dimensions of a, and will be equal for 
c                 square matrices
c        mp,np  - physical dimensions of a
c        NMAX   - maximum anticipated value of n
c        a(1:m) - the input left-hand side
c        w(1:m) - the output singular values
c        v(1:m) - the output matrix, not its transpose
c
      INTEGER m,mp,n,np,NMAX
      DOUBLE PRECISION a(mp,np),v(np,np),w(np)
      PARAMETER (NMAX=500)
CU    USES dpythag
      INTEGER i,its,j,jj,k,l,nm
      DOUBLE PRECISION anorm,c,f,g,h,s,scale,x,y,z,rv1(NMAX),dpythag
      g=0.0d0
      scale=0.0d0
      anorm=0.0d0
      do 25 i=1,n
        l=i+1
        rv1(i)=scale*g
        g=0.0d0
        s=0.0d0
        scale=0.0d0
        if(i.le.m)then
          do 11 k=i,m
            scale=scale+abs(a(k,i))
11        continue
          if(scale.ne.0.0d0)then
            do 12 k=i,m
              a(k,i)=a(k,i)/scale
              s=s+a(k,i)*a(k,i)
12          continue
            f=a(i,i)
            g=-sign(sqrt(s),f)
            h=f*g-s
            a(i,i)=f-g
            do 15 j=l,n
              s=0.0d0
              do 13 k=i,m
                s=s+a(k,i)*a(k,j)
13            continue
              f=s/h
              do 14 k=i,m
                a(k,j)=a(k,j)+f*a(k,i)
14            continue
15          continue
            do 16 k=i,m
              a(k,i)=scale*a(k,i)
16          continue
          endif
        endif
        w(i)=scale *g
        g=0.0d0
        s=0.0d0
        scale=0.0d0
        if((i.le.m).and.(i.ne.n))then
          do 17 k=l,n
            scale=scale+abs(a(i,k))
17        continue
          if(scale.ne.0.0d0)then
            do 18 k=l,n
              a(i,k)=a(i,k)/scale
              s=s+a(i,k)*a(i,k)
18          continue
            f=a(i,l)
            g=-sign(sqrt(s),f)
            h=f*g-s
            a(i,l)=f-g
            do 19 k=l,n
              rv1(k)=a(i,k)/h
19          continue
            do 23 j=l,m
              s=0.0d0
              do 21 k=l,n
                s=s+a(j,k)*a(i,k)
21            continue
              do 22 k=l,n
                a(j,k)=a(j,k)+s*rv1(k)
22            continue
23          continue
            do 24 k=l,n
              a(i,k)=scale*a(i,k)
24          continue
          endif
        endif
        anorm=max(anorm,(abs(w(i))+abs(rv1(i))))
25    continue
      do 32 i=n,1,-1
        if(i.lt.n)then
          if(g.ne.0.0d0)then
            do 26 j=l,n
              v(j,i)=(a(i,j)/a(i,l))/g
26          continue
            do 29 j=l,n
              s=0.0d0
              do 27 k=l,n
                s=s+a(i,k)*v(k,j)
27            continue
              do 28 k=l,n
                v(k,j)=v(k,j)+s*v(k,i)
28            continue
29          continue
          endif
          do 31 j=l,n
            v(i,j)=0.0d0
            v(j,i)=0.0d0
31        continue
        endif
        v(i,i)=1.0d0
        g=rv1(i)
        l=i
32    continue
      do 39 i=min(m,n),1,-1
        l=i+1
        g=w(i)
        do 33 j=l,n
          a(i,j)=0.0d0
33      continue
        if(g.ne.0.0d0)then
          g=1.0d0/g
          do 36 j=l,n
            s=0.0d0
            do 34 k=l,m
              s=s+a(k,i)*a(k,j)
34          continue
            f=(s/a(i,i))*g
            do 35 k=i,m
              a(k,j)=a(k,j)+f*a(k,i)
35          continue
36        continue
          do 37 j=i,m
            a(j,i)=a(j,i)*g
37        continue
        else
          do 38 j= i,m
            a(j,i)=0.0d0
38        continue
        endif
        a(i,i)=a(i,i)+1.0d0
39    continue
      do 49 k=n,1,-1
        do 48 its=1,30
          do 41 l=k,1,-1
            nm=l-1
            if((abs(rv1(l))+anorm).eq.anorm)  goto 2
            if((abs(w(nm))+anorm).eq.anorm)  goto 1
41        continue
1         c=0.0d0
          s=1.0d0
          do 43 i=l,k
            f=s*rv1(i)
            rv1(i)=c*rv1(i)
            if((abs(f)+anorm).eq.anorm) goto 2
            g=w(i)
            h=dpythag(f,g)
            w(i)=h
            h=1.0d0/h
            c= (g*h)
            s=-(f*h)
            do 42 j=1,m
              y=a(j,nm)
              z=a(j,i)
              a(j,nm)=(y*c)+(z*s)
              a(j,i)=-(y*s)+(z*c)
42          continue
43        continue
2         z=w(k)
          if(l.eq.k)then
            if(z.lt.0.0d0)then
              w(k)=-z
              do 44 j=1,n
                v(j,k)=-v(j,k)
44            continue
            endif
            goto 3
          endif
          if(its.eq.30) pause 'no convergence in svdcmp'
          x=w(l)
          nm=k-1
          y=w(nm)
          g=rv1(nm)
          h=rv1(k)
          f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0d0*h*y)
          g=dpythag(f,1.0d0)
          f=((x-z)*(x+z)+h*((y/(f+sign(g,f)))-h))/x
          c=1.0d0
          s=1.0d0
          do 47 j=l,nm
            i=j+1
            g=rv1(i)
            y=w(i)
            h=s*g
            g=c*g
            z=dpythag(f,h)
            rv1(j)=z
            c=f/z
            s=h/z
            f= (x*c)+(g*s)
            g=-(x*s)+(g*c)
            h=y*s
            y=y*c
            do 45 jj=1,n
              x=v(jj,j)
              z=v(jj,i)
              v(jj,j)= (x*c)+(z*s)
              v(jj,i)=-(x*s)+(z*c)
45          continue
            z=dpythag(f,h)
            w(j)=z
            if(z.ne.0.0d0)then
              z=1.0d0/z
              c=f*z
              s=h*z
            endif
            f= (c*g)+(s*y)
            x=-(s*g)+(c*y)
            do 46 jj=1,m
              y=a(jj,j)
              z=a(jj,i)
              a(jj,j)= (y*c)+(z*s)
              a(jj,i)=-(y*s)+(z*c)
46          continue
47        continue
          rv1(l)=0.0d0
          rv1(k)=f
          w(k)=x
48      continue
3       continue
49    continue
      return
      END
c
c----------------------------------------------------------------------X
c
      FUNCTION dpythag(a,b)
      DOUBLE PRECISION a,b,dpythag
      DOUBLE PRECISION absa,absb
      absa=abs(a)
      absb=abs(b)
      if(absa.gt.absb)then
        dpythag=absa*sqrt(1.0d0+(absb/absa)**2)
      else
        if(absb.eq.0.0d0)then
          dpythag=0.0d0
        else
          dpythag=absb*sqrt(1.0d0+(absa/absb)**2)
        endif
      endif
      return
      END
c
c----------------------------------------------------------------------X
c
      SUBROUTINE dsvbksb(u,w,v,m,n,mp,np,b,x)
c
c     Solves |A||x| = |B|, where A is specified by the arrays u,w,v
c     as returned by svdcmp.  
c        m,n    - logical dimensions of a, and will be equal for 
c                 square matrices
c        mp,np  - physical dimensions of a
c        b(1:m) - the input right-hand side
c        x(1:n) - the output soulution vector
c        NMAX   - maximum anticipated value of n
c
c     No input quantities are destroyed, so the routine may be called 
c     sequentially with different b's.
c     
      INTEGER m,mp,n,np,NMAX
      DOUBLE PRECISION b(mp),u(mp,np),v(np,np),w(np),x(np)
      PARAMETER (NMAX=500)
      INTEGER i,j,jj
      DOUBLE PRECISION s,tmp(NMAX)
      do 12 j=1,n
        s=0.0d0
        if(w(j).ne.0.0d0)then
          do 11 i=1,m
            s=s+u(i,j)*b(i)
11        continue
          s=s/w(j)
        endif
        tmp(j)=s
12    continue
      do 14 j=1,n
        s=0.0d0
        do 13 jj=1,n
          s=s+v(j,jj)*tmp(jj)
13      continue
        x(j)=s
14    continue
      return
      END


